# java并发编程的艺术
## 第2章重点内容
    java并发机制的底层实现原理
### 一.volatile(轻量级synchronized)
##### 1.定义:  
简单来说，volatile是**用来保证多线程并发时候共享变量的可见性**的用量修饰符  
1) 什么是共享变量的可见性呢？  
一个线程修改一个共享变量时，另外一个线程能读到修改的值  
2) 是什么模型支撑volatile可行的?  
java线程内存模型确保所有线程看到这个变量的值是**一致**的
##### 2.volatile可见性的底层实现原理
当我们对volatile进行写操作时，JVM会向处理器发送一条**Lock**前缀的指令，在多核处理器下会引发两件事情  
1) 数据写回内存
2) 造成其他CPU缓存该内存地址的数据无效  
  
**那么这是怎么做到的呢？**
每个处理器会自己嗅探在总线上传播的数据从而检查自己缓存的值是不是过期了，发现过期了就重新从内存中读取
##### 3.volatile的使用优化
JDK7的时候新增了一个队列集合类叫**TransferQueue** ,它用追加64字节的方式优化队列出队和入队的性能  

---
### 2.synchronized(大多数情况下是重量级锁)
 **synchronized同步的基础:**  
  java中的每个对象都可以作为锁
  * 对于**普通**同步方法，锁是当前实例对象
  * 对于**静态**同步方法，锁是当前类的Class对象
  * 对于**同步方法块**,锁是Synchronized括号里配置的对象，这个相信大家见的比较多
  * 通过上述可知synchronized本质都是作用于对象上  
**综上我们引出以下问题**
  1) 锁存在哪里？  
java对象头
  2) 锁里面会存放什么信息  
重点了解Mark Word，里面存储对象的hashCode和锁信息
#### 锁的4种状态(按级别升序排序)
1. 无锁
2. 偏向锁  
线程第一次获得锁时，对象头存储锁偏向的线程ID。有竞争出现时才会释放锁
3. 轻量级锁  
使用CAS将对象头的Mark Word替换为指向锁记录的指针，如果成功则获得锁，失败说明有其他线程竞争锁，则当前线程尝试使用自旋CAS获取锁
4. 重量级锁  
当线程处于这个状态时，其他线程视图获取锁时会被阻塞住.持有锁的线程释放锁后，才被唤醒去竞争锁

---

|  锁   |  优点  | 缺点   |   适用场景|
|  ----  | ----  | ----   |   ----| 
| 偏向锁  | 快而且没什么消耗 | 有竞争就会有撤销锁的消耗  |只有一个线程访问同步块 |
| 轻量级锁  | 竞争的线程不会阻塞，提高程序响应速度 | 始终得不到锁竞争的线程会自旋而消耗CPU |追求响应时间 |
| 重量级锁  | 不使用自旋CAS，不会消耗CPU | 线程阻塞，响应时间慢 | 追求吞吐量 |


**记住！,一旦锁升级了，就回不去了**

---
### 3.原子操作的实现原理
1. 术语定义  
* 首先介绍一个大家经常见到的词:CAS  
Compare and Swap
CAS操作需要输入两个数值，一个旧值和一个新值，在操作期间先比较旧值有没有发生变化，没有发生变化才交换成
新值，发生了变化则不交换
* 缓存行:缓存的最小操作单位
---
2. 处理器如何实现原子操作(原子性)  
* (1)总线锁，当一个处理器在总线上输出此信号时，其他处理器的请求会被阻塞，独享共享内存，但是开销大
* (2)缓存锁，利用缓存一致性机制，当其他处理器回写被锁定的缓存行的数据时，会使缓存行无效

---
3. java如何实现原子操作  
**通过锁和循环CAS的方式来实现原子操作**  
1) 使用锁机制实现原子操作  
锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS,
即当一个线程想进人同步块的时候使用循环CAS的方式来获取锁，当它退出回步块的时候使用循环CAS释放锁
2) 使用循环CAS实现原子操作  
自旋CAS实现的基本思路就是循环进行CAS操作知道成功为止  
从Java1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean(用原子方式更新的boolean値)、AtomicInteger和AtomicLong
3) CAS实现原子操作的三大问题
* 3.1)ABA问题  
CAS操作的值从A-->B-->A,虽然最后值没变，但是实际上却变化了  
解决思路:使用版本号
则A-->B-->A就会变成1A-->2B-->3A，就能检测出来了  
JDK的Atomic包下的AtomicStampedReference有一个compareAndSet方法就是使用这个方法双重检查数据
* 3.2)循环时间长开销大（自旋CAS长时间不成功）  
解决思路：JVM支持处理器的pause指令
* 3.2)只能保证一个共享变量的原子操作  
解决办法:用锁或者把多个共享变量合并成一个操作，java的AtomicReference类就可以将多个变量放在一个对象里


### 总结
研究了volatile,synchronized和原子操作的原理，因为java的大部分容器和框架都依赖这些原理，了解这些原理有利于我们进行并发编程