# java并发编程的艺术
## 第三章重点内容  
### 3.1 java内存模型的基础
###### java内存模型(JMM)
java并发采用的是共享内存模型，线程之间的通信是透明的,由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见  

###### 下面是线程通信的抽象解析  
线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(JMM的抽象概念，实际上并不存在)  
1）线程A把本地内存A中更新的共享变量刷新到主内存中  
2）线程B从主内存中读取共享变量  
**JMM通过控制主内存与每个线程的本地内存之间的交互，来为java新成员提供内存可见性保证**  
###### 内存可见性  
内存可见性(Memory Visibility)是指当某个线程正在使用对象状态而另一个线程在同时修改该状态,需要确保当一个线程修改了对象状态后,其他线程能够看到发生的状态变化。  

###### 重排序  
``为了提高性能，编译器和处理器常常会对指令做重排序，分为三种类型``  
1.编译器优化的重排序  
2.指令级并行的重排序，将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序  
3.内存系统的重排序，处理器使用缓存和读写缓冲区  
源代码到最终执行的指令序列，会分别经历1，2，3种重排序类型  

###### 现代处理器使用写缓冲区临时保存向内存写入的数据，每个处理器上的写缓冲区只对所在的处理器可见  
**上述特性会导致处理器对内存的读写操作顺序不一定与内存实际的读写操作顺序一致!**  

###### happens-before  
``如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系,这里的操作可以一个线程内也可以多个线程间 ``  
* 程序顺序规则:一个线程的每个操作，happens-before于该线程中的任意后续操作  
* 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁  
* volatile变量规则:对一个volatile域的写，happens-before于后续的读  
* 传递性，A --> B,B-->C,则A-->C (-->代表happens-before)

两个操作之间具有happens-before关系，并不意味着前一个操作必须在后一个操作之气执行  
仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排序在第二个操作之前  

### 3.2 重排序  
  重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段  

###### 数据依赖性  
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性  
  
| 名称 | 代码示例 | 
| ---  |   ---   | 
| 写后读| a=1;b=a; | 
| 写后写| a=1;a=2; |
| 读后写| a=b;b=1;|  

编译器和处理器会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序(单处理器和单线程情况下)  

###### as-if-serial语义  
不管怎么重排序，单线程执行的结果不能被改变  
###### 重排序对多线程的影响  
单线程的时候不会改变执行结果，但在多线程中对存在控制依赖的操作重排序时，可能会改变程序的执行结果  
### 3.3顺序一致性  
顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性的内存模型进行参照  
###### 数据竞争与顺序一致性            
数据竞争: 在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序  
如果这个多线程能正确同步，这个程序是一个没有数据竞争的程序  
JMM对正确同步的多线程程序的内存一致性做了保证：  
正确同步的程序执行将具有顺序一致性 —— 程序的执行结果与程序在顺序一致性模型中的执行结果相同      
这里说的同步是广义的包括正确使用Synchronized，volatile，final   


###### 详解顺序一致性模型 
它为程序员提供了极强的内存可见性保证   
**两大特性**     
1. 一个线程中的所有操作必须按照程序的顺序来执行    
2. 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。每个操作都必须原子执行并立刻对所有线程可见  
**顺序一致性模型视图**    
![img.png](img.png)    

**顺序一致性模型有一个单一的全局内存，通过左右摇摆连接到任意一个线程，最多只有一个线程可以连接到内存**   
**并发执行时：将所有线程的内存读写操作串行化   **
1）AB线程正确同步的执行效果：    
![img_1.png](img_1.png)   
所有线程只能看到一致执行顺序A1->A2->A3->B1->B2->B3   
2）AB线程没有做同步的执行效果：    
![img_2.png](img_2.png)   
虽然没有同步，导致整体执行顺序无序，但是所有线程都只能看到一个一致的整体顺序：B1->A1->A2->B2->A3->B3    

**但是在JMM中未同步程序没有这个特性，不仅执行顺序无序而且线程看到的整体执行顺序也不一样**  

###### 在顺序一致性模型中，所有操作完全按程序的顺序串行执行，而在JMM中，是可以有在临界区内代码的重排序操作的   

### volatile的内存语义   







