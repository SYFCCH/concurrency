# java并发编程的艺术

```这章是真的晦涩，只提取了我认为有启发的知识点```   

核心学习内容：从多个方面去体会理解JMM，能有个比较深入的了解，解决java并发编程中经常遇到的各种内存可见性问题       


## 第三章重点内容  
### 3.1 java内存模型的基础
###### java内存模型(JMM)
java并发采用的是共享内存模型，线程之间的通信是透明的,由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见  

###### 下面是线程通信的抽象解析  
线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(JMM的抽象概念，实际上并不存在)  
1）线程A把本地内存A中更新的共享变量刷新到主内存中  
2）线程B从主内存中读取共享变量  
**JMM通过控制主内存与每个线程的本地内存之间的交互，来为java新成员提供内存可见性保证**  

JMM的抽象模型   

![img_4.png](img_4.png)    

举例子：   
![img_3.png](img_3.png)    

如图3-2所示,本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个内存中的x值都为0。线程A在执行时，把更新后的x值(假设值为1)临时存放在自己的本地内存A中。当线程A和线程B需要通信时,线程A首先会把自己本地内存中修改后的x值刷新到主内存中,此时主内存中的x值变为了1。随后，线程B到主内存中去读
取线程A更新后的x值,此时线程B的本地内存的x值也变为了1。
从整体来看,这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。

JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。 


###### 内存可见性  
内存可见性(Memory Visibility)是指当某个线程正在使用对象状态而另一个线程在同时修改该状态,需要确保当一个线程修改了对象状态后,其他线程能够看到发生的状态变化。  

###### 重排序  
``为了提高性能，编译器和处理器常常会对指令做重排序，分为三种类型``  
1.编译器优化的重排序  
2.指令级并行的重排序，将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序  
3.内存系统的重排序，处理器使用缓存和读写缓冲区  
源代码到最终执行的指令序列，会分别经历1，2，3种重排序类型  

###### 现代处理器使用写缓冲区临时保存向内存写入的数据，每个处理器上的写缓冲区只对所在的处理器可见  
**上述特性会导致处理器对内存的读写操作顺序不一定与内存实际的读写操作顺序一致!**  

###### happens-before  
``如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系,这里的操作可以一个线程内也可以多个线程间 ``  
* 程序顺序规则:一个线程的每个操作，happens-before于该线程中的任意后续操作  
* 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁  
* volatile变量规则:对一个volatile域的写，happens-before于后续的读  
* 传递性，A --> B,B-->C,则A-->C (-->代表happens-before)

两个操作之间具有happens-before关系，并不意味着前一个操作必须在后一个操作之气执行  
仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排序在第二个操作之前  

### 3.2 重排序  
  重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段  

###### 数据依赖性  
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性  
  
| 名称 | 代码示例 | 
| ---  |   ---   | 
| 写后读| a=1;b=a; | 
| 写后写| a=1;a=2; |
| 读后写| a=b;b=1;|  

编译器和处理器会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序(单处理器和单线程情况下)  

###### as-if-serial语义  
不管怎么重排序，单线程执行的结果不能被改变  
###### 重排序对多线程的影响  
单线程的时候不会改变执行结果，但在多线程中对存在控制依赖的操作重排序时，可能会改变程序的执行结果  
### 3.3顺序一致性  
顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性的内存模型进行参照  
###### 数据竞争与顺序一致性            
数据竞争: 在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序  
如果这个多线程能正确同步，这个程序是一个没有数据竞争的程序  

----
JMM对正确同步的多线程程序的内存一致性做了保证：    **注意这里是对正确同步，不同步的话和理想的顺序一致性模型那是不一样的**     

----

正确同步的程序执行将具有顺序一致性 —— 程序的执行结果与程序在顺序一致性模型中的执行结果相同      
这里说的同步是广义的包括正确使用Synchronized，volatile，final   


###### 详解顺序一致性模型 
它为程序员提供了极强的内存可见性保证   
**两大特性**     
1. 一个线程中的所有操作必须按照程序的顺序来执行    
2. 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。每个操作都必须原子执行并立刻对所有线程可见  
**顺序一致性模型视图**    
![img.png](img.png)    

**顺序一致性模型有一个单一的全局内存，通过左右摇摆连接到任意一个线程，最多只有一个线程可以连接到内存**   
**并发执行时：将所有线程的内存读写操作串行化**
1）AB线程正确同步的执行效果：    
![img_1.png](img_1.png)   
所有线程只能看到一致执行顺序A1->A2->A3->B1->B2->B3   
2）AB线程没有做同步的执行效果：    
![img_2.png](img_2.png)   
虽然没有同步，导致整体执行顺序无序，但是所有线程都只能看到一个一致的整体顺序：B1->A1->A2->B2->A3->B3    

**但是在JMM中未同步程序没有这个特性，不仅执行顺序无序而且线程看到的整体执行顺序也不一样**  

###### 在顺序一致性模型中，所有操作完全按程序的顺序串行执行，而在JMM中，是可以有在临界区内代码的重排序操作的   


###  3.4 volatile的内存语义    
#### volatile特性  
* 可见性：对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入
* 原子性：对任意**单个**volatile变量的读/写具有原子性，(类似于volatile++这种复合操作除外)

多个线程对**单个**volatile变量的读写操作与一个普通变量加了同一个锁来同步的效果是一样的     

锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味对一个volatile变量的读，都能看到任意线程对这个变量最后的写(修改)    



这里说明，只要你用的是jdk5及以后的版本，volatile变量的读写可以实现线程之间的通信    

#### volatile读写的内存语义          

内存语义来说，锁的**获取和释放**可以和volatile的**写和读**对应   (注意顺序，获取和写对应)           

当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存   

当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效。线程接下来将从主内存读取共享变量    




知识点总结：    
线程A写一个volatile变量，实际上是线程A向接下来将要读这个volatile变量的某个线程发出了其对共享变量所作修改的消息
线程B读一个volatile变量，实际上是线程B接收了之前某个线程发出的信息(这个线程是写volatile)    
线程A写volatile变量到线程B读volatile变量，实质上是A通过主内存向B发送消息   

![img_5.png](img_5.png)     


#### volatile内存语义的实现   
简单来说就是JMM会限制编译器重排序和处理器重排序   

编译器在在生成字节码的时候，在指令序列中插入内存屏障，来禁止特定类型的处理器重排序   
JMM采取保守策略(首先保证正确再保证效率)来插入内存屏障。    

对volatile写



对volatile读    




## 3.5 锁的内存语义


* 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了(线程A对共享变量所做修改的)信息   

* 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的(在释放这个锁之前对共享变量的修改)消息   


线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息    


![img_6.png](img_6.png)     

实现的



#### volatile和锁简单对比
volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。
在功能上锁比volatile更强大   
在可伸缩性(不会像锁那样造成线程阻塞)和执行性能上，volatile更有优势

您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
* 对变量的写操作不依赖于当前值。
* 该变量没有包含在具有其他变量的不变式中




## 3.6 final域的内存语义    

  





前面的happens-before只学了皮毛，现在来具体学学  

## 3.7 happens-before


## 3.8 双重检查锁定与延迟初始化   


