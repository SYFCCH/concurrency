# java并发编程的艺术
## 第三章重点内容  
### 3.1 java内存模型的基础
###### java内存模型(JMM)
java并发采用的是共享内存模型，线程之间的通信是透明的,由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见  

###### 下面是线程通信的抽象解析  
线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(JMM的抽象概念，实际上并不存在)  
1）线程A把本地内存A中更新的共享变量刷新到主内存中  
2）线程B从主内存中读取共享变量  
**JMM通过控制主内存与每个线程的本地内存之间的交互，来为java新成员提供内存可见性保证**  
###### 内存可见性  
内存可见性(Memory Visibility)是指当某个线程正在使用对象状态而另一个线程在同时修改该状态,需要确保当一个线程修改了对象状态后,其他线程能够看到发生的状态变化。  

###### 重排序  
``为了提高性能，编译器和处理器常常会对指令做重排序，分为三种类型``  
1.编译器优化的重排序  
2.指令级并行的重排序，将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序  
3.内存系统的重排序，处理器使用缓存和读写缓冲区  
源代码到最终执行的指令序列，会分别经历1，2，3种重排序类型  

###### 现代处理器使用写缓冲区临时保存向内存写入的数据，每个处理器上的写缓冲区只对所在的处理器可见  
**上述特性会导致处理器对内存的读写操作顺序不一定与内存实际的读写操作顺序一致!**  

###### happens-before  
``如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系,这里的操作可以一个线程内也可以多个线程间 ``  
* 程序顺序规则:一个线程的每个操作，happens-before于该线程中的任意后续操作  
* 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁  
* volatile变量规则:对一个volatile域的写，happens-before于后续的读  
* 传递性，A --> B,B-->C,则A-->C (-->代表happens-before)

两个操作之间具有happens-before关系，并不意味着前一个操作必须在后一个操作之气执行  
仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排序在第二个操作之前  

### 3.2 重排序  
  重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段  

###### 数据依赖性  
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性  
  
| 名称 | 代码示例 | 
| ---  |   ---   | 
| 写后读| a=1;b=a; | 
| 写后写| a=1;a=2; |
| 读后写| a=b;b=1;|  

编译器和处理器会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序(单处理器和单线程情况下)  

###### as-if-serial语义  
不管怎么重排序，单线程执行的结果不能被改变  
###### 重排序对多线程的影响  
单线程的时候不会改变执行结果，但在多线程中对存在控制依赖的操作重排序时，可能会改变程序的执行结果  















