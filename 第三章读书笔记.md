# java并发编程的艺术
## 第三章重点内容  
### 3.1 java内存模型的基础
###### java内存模型(JMM)
java并发采用的是共享内存模型，线程之间的通信是透明的,由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见  

###### 下面是线程通信的抽象解析  
线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存(JMM的抽象概念，实际上并不存在)  
1）线程A把本地内存A中更新的共享变量刷新到主内存中  
2）线程B从主内存中读取共享变量  
**JMM通过控制主内存与每个线程的本地内存之间的交互，来为java新成员提供内存可见性保证**  

###### 重排序  
``为了提高性能，编译器和处理器常常会对指令做重排序，分为三种类型``  
1.编译器优化的重排序  
2.指令级并行的重排序，将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序  
3.内存系统的重排序，处理器使用缓存和读写缓冲区  
源代码到最终执行的指令序列，会分别经历1，2，3种重排序类型  

###### 现代处理器使用写缓冲区临时保存向内存写入的数据，每个处理器上的写缓冲区只对所在的处理器可见  
**上述特性会导致处理器对内存的读写操作顺序不一定与内存实际的读写操作顺序一致!**  

###### happens-before  
``如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系,这里的操作可以一个线程内也可以多个线程间 ``  
* 程序顺序规则:一个线程的每个操作，happens-before于该线程中的任意后续操作  
* 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁  
* volatile变量规则:对一个volatile域的写，happens-before于后续的读  
* 传递性，A --> B,B-->C,则A-->C (-->代表happens-before)

### 3.2 重排序
 
